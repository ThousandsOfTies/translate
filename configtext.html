<!DOCTYPE html>
<html lang="ja"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>D&D</title>
    <style type="text/css">
      .draggable {
          position:relative;
          user-select:none;
          cursor:pointer;
          z-index:2;
      }
      .holding {
          opacity:.5;
      }
      #working_tray {
          background-color:#eeffee;
          height:100px;
      }
      #words_tray {
          background-color:#ffeeee;
          height:100px;
      }
    </style>
  </head>
  <body>
    <select id="voice-select" />
    <input id="voice-test" type="button" value="視聴" />
    <div id="working_tray" class="tray">
    </div>
    <table>
      <tr><td><div id="jan">{日本語}</div></td><td>⇒</td><td><div id="eng">{英語}</div></td></tr>
    </table>
    <div id="words_tray" class="tray">
    </div>
    <script>
      class StatementSynthesiser {
          constructor (elm, statement_class_name) {
              this.statements_place = elm;
              this.statement_class_name = statement_class_name;
              this.voice = {};
              this.num = 0;
              this.prevX = 0;
              this.prevY = 0;
          }
          setVoice (voice) {
              this.voice = voice;
          }
          insertStatements (statements) {
              statements.forEach( statement => {
                  const add_code = '<span id="' + this.num++ + '" class="' + this.statement_class_name + ' draggable" data-origin="' + statement + '">' + statement + '</span>';
                  this.statements_place.insertAdjacentHTML('beforeend', add_code);
              });
              document.querySelectorAll("."+this.statement_class_name).forEach( elm => {
                  elm.addEventListener('mousedown', ev => {
                      ev.target.classList.add("holding");
                  });
                  elm.addEventListener('mousemove', ev => {
                      if(ev.target.classList.contains('holding')==false){
                          return;
                      }
                      ev.target.classList.add("dragging");
                      var style = getComputedStyle(ev.target);
                      ev.target.style.top  = (parseInt(style.top, 10) +  ev.movementY ) + "px";
                      ev.target.style.left = (parseInt(style.left, 10) + ev.movementX ) + "px";
                  });
                  elm.addEventListener('mouseup', ev => {
                      let isDragging = ev.target.classList.contains('dragging');
                      ev.target.classList.remove("dragging");
                      ev.target.classList.remove("holding");
                      if(isDragging){
                          return;
                      }
                      const uttr = new SpeechSynthesisUtterance(ev.target.textContent);
                      uttr.voice = this.voice;
                      speechSynthesis.speak(uttr);
                      return false;
                  });
                  elm.addEventListener('mouseout', ev => {
                      ev.target.classList.remove("holding");
                      ev.target.classList.remove("dragging");
                  });

                  // taouch panel用
                  elm.addEventListener('touchstart', ev => {
                      ev.target.classList.add("holding");
                      this.prevX = ev.touches[0].clientX;
                      this.prevY = ev.touches[0].clientY;
                  });
                  elm.addEventListener("touchmove", ev => {
                      if(ev.target.classList.contains('holding')==false){
                          return;
                      }
                      let x = ev.touches[0].clientX - this.prevX;
                      let y = ev.touches[0].clientY - this.prevY;
                      this.prevX = ev.touches[0].clientX;
                      this.prevY = ev.touches[0].clientY;
                      var style = getComputedStyle(ev.target);
                      ev.target.style.top  = (parseInt(style.top, 10) +  y ) + "px";
                      ev.target.style.left = (parseInt(style.left, 10) + x ) + "px";
                  });
                  elm.addEventListener('touchend', ev => {
                      ev.target.classList.remove("holding");
                  });
              });
          }
          translateIntoEng(tlx, tly, brx, bry) {
              let words_on_tray = [];
              document.querySelectorAll('.' + this.statement_class_name).forEach ( word => {
                  let cr = word.getBoundingClientRect();
                  let left = window.pageXOffset + cr.left;
                  let top  = window.pageYOffset + cr.top;
                  if ( bry < top ) {
                      return;
                  }
                  console.log(word);
                  words_on_tray.push(word);
              });
              let statement = '';
              words_on_tray.forEach ( word => {
                  statement = statement + word.textContent+ ' ';
              });
              statement = statement + "。";
              document.querySelector('#jan').textContent = statement;
              fetch('https://script.google.com/macros/s/AKfycbzaYhG3i8Q8G-jp0t5DK04qAe7v11od6WVdcNtkvrR6a58b4CbBSgdWmW4QWZ4kFM3l/exec?translate="' + statement + '"&source=ja&target=en')
                  .then(response => {
                      return response.json();
                  })
                  .then(json => {
                      document.querySelector('#eng').textContent = json;
                      const uttr = new SpeechSynthesisUtterance(json);
                      uttr.voice = this.voice;
                      speechSynthesis.speak(uttr);
                      return;
                  });
          }
          translateBack() {
              document.querySelectorAll('.' + this.statement_class_name).forEach ( statement => {
                  statement.textContent = statement.dataset.origin;
              });
          }
      }

      let wt = document.querySelector("#words_tray");
      let ss = new StatementSynthesiser(wt, "statement");
      ss.insertStatements(['私は', '千尋は', '食べる', '買う', 'バナナ', 'いちご', '昨日']);
      document.querySelector("#working_tray").addEventListener('click', e => {
          let cr = e.target.getBoundingClientRect();
          let tlx = window.pageXOffset + cr.left;
          let tly = window.pageYOffset + cr.top;
          let brx = tlx + cr.width;
          let bry = tly + cr.height;
          console.log('id = ' + e.target.id + ' top left (x, y) = (' + tlx + ', ' + tly + ')');
          console.log('id = ' + e.target.id + ' bottom right (x, y = (' + brx + ', ' + bry + ')');
          ss.translateIntoEng(tlx, tly, brx, bry);
      });

      function updateVoiceSelect( elm ) {
          const voices = speechSynthesis.getVoices();
          elm.innerHTML = '';

          let matched_voices = [];
          voices.forEach( v => {
              if(!v.lang.match('en-US')) {
                  return;
              }
              const option = document.createElement('option');
              option.value = v.name;
              option.text  = `${v.name} (${v.lang});`;
              option.setAttribute('selected', v.default);
              elm.appendChild(option);
              matched_voices.push(v);
          });
          let arg_voice = matched_voices.filter( voice => voice.name == elm.value)[0];
          ss.setVoice(arg_voice);
      }
      let voiceSelect = document.querySelector('#voice-select');
      voiceSelect.onchange = ev => {
          ss.setVoice( speechSynthesis
                       .getVoices()
                       .filter(voice => voice.name === ev.target.value)[0] );
      };
      speechSynthesis.onvoiceschanged = e => {
          updateVoiceSelect(voiceSelect);
      }

      let voiceTest = document.querySelector('#voice-test');
      voiceTest.addEventListener('click', function() {
          const uttr = new SpeechSynthesisUtterance("Hello, world!");
          uttr.voice = speechSynthesis
              .getVoices()
              .filter(voice => voice.name === voiceSelect.value)[0];
          speechSynthesis.speak(uttr);
      });
      </script>
  </body>
</html>
